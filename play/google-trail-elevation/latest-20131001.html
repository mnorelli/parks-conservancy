<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <style>

      body {
        font-family: Helvetica, Arial, 'Sans Serif';
      }

      body,
      svg,
      #map {
        margin: 0;
        padding: 0;
      }

      #map {
        height: 400px;
      }

      path.elevation {
        fill: none;
        stroke: #000;
        stroke-width: 2;
      }

      .axis path,
      .axis line {
        fill: none;
        stroke: black;
        shape-rendering: crispEdges;
      }

      .axis text {
        font-family: sans-serif;
        font-size: 11px;
      }

/*      img {
        filter: grayscale(100%);
        -webkit-filter: grayscale(100%);
        -moz-filter: grayscale(100%);
        -o-filter: grayscale(100%);
        -ms-filter: grayscale(100%);
      }*/

      #map-legend {
        position: fixed;
        top: 350px;
        right: 0;
        padding: 5px;
        width: 100px;
        font-size: 11px;
      }

      #metadata {
        font-size: 11.5px;
        padding: 20px;
        margin-left: 25%;
        width: 50%;
      }

      path.elevation-mouseover {
        stroke-width: 40;
        stroke: #000;
        opacity: 0;
      }

      #trips {
        position: fixed;
        top: 20px;
        left: 100px;
      }

    </style>
  </head>
  <body>

    <div id="map"></div>
    <div id="map-legend"></div>
    <div id="chart"></div>
    <div id="metadata"></div>
    <div id="trips">
      <select></select>
    </div>

    <script src="js/d3.v3.js"></script>
    <script src="https://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false"></script>
    <script src="js/customTiles.js"></script>

    <script>

      // default sample trail profile
      var elevationProfileFile = "elevation-profile-metadata.json";
      
      // available trips
      var trips = [
        "Select a trip ID",
        1287, 1424, 1431, 89, 45, 1297, 216, 
        1338, 1446, 1295, 140, 1333, 63, 1448, 
        1449, 263, 1433
      ];

      // check querystring for a trip id to load, otherwise use the default sample
      var qs = window.location.search.substr(1);
      if (qs) {
        
        var terms = qs.split("&").map(function(t) { return t.split("="); }),
            args = {};
        
        terms.forEach(function(t) { args[t[0]] = t[1]; });  // array to object

        if (args.id && trips.indexOf(+args.id) > -1) {
          var elevationProfileFile = "trips-elevation/" + args.id + ".json";
        }
      }

      // for selecting a TnT trip from a dropdown menu
      var tripsDropdown = d3.select("#trips select");
      tripsDropdown.selectAll("option")
          .data(trips)
        .enter().append("option")
          .attr("value", String)
          .text(String);

      tripsDropdown.on("change", function(e) {
        var selected = tripsDropdown.node().selectedOptions[0].value;
        if (selected !== "Select a trip ID")
          window.location.search = "?id=" + selected;
      });


      // create our graph/elevation profile svg container
      var width = window.innerWidth,
          height = 200,
          padding = 20;

      var svg = d3.select("#chart")
          .append("svg")
            .attr("width", width)
            .attr("height", height);

      // distance is in miles, height is in feet. need to convert.
      function milesToFeet(mi) {
        return 5280 * mi;
      }

      // clear an overlay from the map. should probably have a resetMap() function too
      // to clear everything
      function clearOverlay(overlay) {
        if (overlay) 
          overlay.setMap(null);
      }

      var debug = {},
          overlays = {};

      d3.json(elevationProfileFile, function(err, profile) {

        var elevation = profile.elevation;
        debug.elevation = elevation;

        // create the map (uses a custom tileset with code from js/customTiles.js)
        d3.select("#map").style("width", width + "px");
        var mid = elevation[~~(elevation.length/2)].coordinates;  // take a point from the middle of the route as a center
        var center = new google.maps.LatLng(mid[0], mid[1]);
        var mapOptions = {
          zoom: 14,
          center: center,
          mapTypeControlOptions: {
            mapTypeIds: ['ggnra']
          }
        };
        var map = new google.maps.Map(document.getElementById('map'), mapOptions);
        map.mapTypes.set('ggnra', mapType);
        map.setMapTypeId('ggnra');

        // a "route" is two contiguous lat/lng pairs
        var route = elevation.map(function(d) { 
          var c = d.coordinates;
          return new google.maps.LatLng(c[0], c[1]); 
        });

        var maxDist = d3.max(elevation, function(d) { return milesToFeet(d.distance); }),
            maxHeight = d3.max(elevation, function(d) { return d.height; });
        var maxScale = Math.max(maxDist, maxHeight);  // so everything is in proportion

        // calculate the change in steepness for every segment
        var heightDeltas = route.map(function(point, i) {
          if (i === route.length-1) return 0;
          return elevation[i].height - elevation[i+1].height;
        }).sort(d3.ascending);

        // overall elevation change (for the metadata)
        var elevationChange = d3.sum(heightDeltas.map(function(d) { return Math.abs(d); }));

        // display some metadata (from TnT, mostly)
        var metadata = [
          "<h3>" + profile.metadata.name + "</h3>",
          "<b>Duration: </b>" + profile.metadata.duration,
          "<b>Elevation Change: </b>" + elevationChange.toFixed(2) + "ft",
          "<b>Length: </b>" + profile.metadata.length_miles.toFixed(2) + " miles",
          "<b>Intensity: </b>" + profile.metadata.intensity,
          "<b>Description: </b>" + profile.metadata.description.replace(/[\n\r\t]/g, "").replace(/\<p\>/g, "")
        ].join("<br>");
        d3.select("#metadata").html(metadata);

        // stroke color of segment polyline as a function of segment elevation
        var heightColorScale = d3.scale.linear()
              .domain([0, maxHeight])
              .range(["hsl(200, 100%, 70%)", "hsl(360, 100%, 70%)"]);

        // stroke color of segment polyline as a function of segment steepness
        var steepnessColorScale = d3.scale.linear()
              .domain(d3.extent(heightDeltas))
              .range(["hsl(150, 100%, 70%)", "hsl(0, 100%, 70%)"]);

        // stroke weight of segment polyline as a function of segment steepness
        var steepnessStrokeWeight = d3.scale.linear()
              .domain(d3.extent(heightDeltas))
              .range([20, 2]);

        var minHeight = heightDeltas[0];

        // fill the map legend
        var mapLegend = d3.select("#map-legend");
        var gradient = "linear-gradient(to right, " + steepnessColorScale(minHeight) + ", " + steepnessColorScale(maxHeight) +")";
        mapLegend.style("background-image", gradient);
        mapLegend
          .append("div")
            .style("float", "left")
            .text(~~heightDeltas[0] + "ft");
        mapLegend
          .append("div")
            .style("float", "right")
            .style("text-align", "right")
            .text(~~heightDeltas[heightDeltas.length-1] + "ft");

        route.forEach(function(point, i) {
          if (i === route.length-1) return;
          var primary = i,
              secondary = i+1;

          var segment = [route[primary], route[secondary]],
              maxSegmentHeight = d3.max([elevation[primary].height, elevation[secondary].height]),
              // strokeWeight = (maxSegmentHeight / maxHeight) * 20,
              heightDelta = elevation[primary].height - elevation[secondary].height,  // you're going "forwards" on a trail
              strokeWeight = steepnessStrokeWeight(heightDelta);

          var routePath = new google.maps.Polyline({
            path: segment,
            strokeColor: "black", //steepnessColorScale(heightDelta), //heightColorScale(maxSegmentHeight),
            strokeOpacity: 1,
            strokeWeight: strokeWeight
          });

          routePath.setMap(map);
          
          // when you mouseover the "route"/segment on the map, the same segment is highlighted on the
          // elevation profile
          google.maps.event.addListener(routePath, "mouseover", function() {
            var sister = svg.select(".route-segment" + i),
                locStr = sister.attr("d").substr(1).split(/[ML]/g),
                first = locStr[0].split(",").map(Number),
                next = locStr[1].split(",").map(Number),
                midx = (first[0] + next[0]) / 2,
                midy = (first[1] + next[1]) / 2;

            // console.log(sister, locStr, midx, midy);
            var overlay = svg.append("circle")
                  .datum(elevation[i])
                    .attr("cx", midx)
                    .attr("cy", midy)
                    .attr("r", 10)
                    .attr("transform", "translate(" + width/4 + "," + padding + ")")
                    .style("fill", "red")
                    .style("opacity", 0.8);

            overlays.map2graph = overlay;
          });

          google.maps.event.addListener(routePath, "mouseout", function() {
            overlays.map2graph.remove();
            overlays.map2graph = null;
          });
        });


        // create the elevation profile graph (below the map)

        // var clamp = d3.scale.linear().domain([0, maxScale]).range([padding, 500]); // proportional scale
        var x = d3.scale.linear().domain([0, maxDist]).range([padding, 800]);
        var y = d3.scale.linear().domain([0, maxHeight]).range([100, padding]);

        var line = d3.svg.line()
              .x(function(d) { return x(milesToFeet(d.distance)); })
              .y(function(d) { return y(d.height); });

        // move the container over so it's "centered"
        var g = svg.append("g")
          .attr("transform", "translate(" + width/4 + "," + padding + ")");

        // the invisible profile with a huge width (since it's hard to mouseover a tiny line)
        var elevationData = elevation.slice(1);
        var elevationPoints = g.selectAll("path")
            .data(elevationData)
          .enter().append("path")
          .attr("class", function(d, i) { return "elevation-mouseover route-segment" + (i+1); })
          .attr("d", function(d, i) {
            if (i === elevationData.length-1) return "M0,0";
            return line([d, elevationData[i+1]]); 
          });

        // the visible elevation profile
        g.selectAll("path.elevation")
            .data(elevationData)
          .enter().append("path")
          // .attr("class", "elevation")
          .attr("class", function(d, i) { return "elevation"; }) // route-segment" + (i+1); })
          .attr("d", function(d, i) {
            if (i === elevationData.length-1) return "M0,0";
            return line([d, elevationData[i+1]]); 
          });

        var r = d3.scale.linear().domain([0, maxHeight]).range([1, 20]);
        
        // console.log(elevation);
        // var elevationPoints = g.append("g").selectAll("circle")
        //   .data(elevation)
        // .enter().append("circle")
        //   .attr("cx", function(d) { return x(milesToFeet(d.distance)); })
        //   .attr("cy", function(d) { return y(d.height); })
        //   .attr("r", function(d) { return r(d.height); })
        //   .attr("fill", function(d) { return heightColorScale(d.height); })
        //   .attr("stroke", "none")
        //   .attr("stroke-width", "0");

        // when you mouseover the elevation profile segments, it highlights the same 
        // segment on the map
        elevationPoints.on("mouseover", function(e) {
          var markerStyle = {
            strokeColor: '#FF0000',
            strokeOpacity: 0.8,
            strokeWeight: 2,
            fillColor: '#FF0000',
            fillOpacity: 0.35,
            map: map,
            center: new google.maps.LatLng(e.coordinates[0], e.coordinates[1]),
            radius: 50,
            zIndex: 99999999999
          };
          var marker = new google.maps.Circle(markerStyle);
          overlays.graph2map = marker;
        });

        elevationPoints.on("mouseout", function(e) {
          clearOverlay(overlays.graph2map);
        });

        // the legend for the circle-based elevation profile graph
        // g.append("g").selectAll("circle")
        //   .data(elevation)
        // .enter().append("circle")
        //   .attr("cx", 21)
        //   .attr("cy", function(d) { return y(d.height); })
        //   .attr("r", function(d) { return r(d.height); })
        //   .attr("fill", function(d) { return heightColorScale(d.height); })
        //   .attr("stroke", "none")
        //   .attr("stroke-width", "0");

        // axes for the elevation profile
        var xAxis = d3.svg.axis()
            .scale(x)
            .orient("bottom")
            .ticks(5);  //Set rough # of ticks

        g.append("g")
            .attr("class", "axis")
            .attr("transform", "translate(0, 100)")
            .call(xAxis);

        // Define Y axis
        var yAxis = d3.svg.axis()
            .scale(y)
            .orient("left")
            .ticks(5);

        //Create Y axis
        g.append("g")
            .attr("class", "axis")
            .attr("transform", "translate(" + padding + ",0)")
            .call(yAxis);
      });

    </script>

  </body>
</html>