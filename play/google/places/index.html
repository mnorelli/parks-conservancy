<!DOCTYPE html>
</html>
<head>
    <title>Google Places in Parks</title>
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no">
    <meta charset="utf-8">

    <link rel="stylesheet" type="text/css" href="css/normalize.css">
    <link rel="stylesheet" type="text/css" href="css/index.css">
    <style>
        *{
            box-sizing: border-box;
        }
        body, html{
            width: 100%;
            height: 100%;
        }
        body{
            margin: 0;
            padding: 0;
            font-family: 'Helvetica Neue', helvetica, 'Source Sans', arial, sans-serif;
        }
        label{

        }
        button{padding: 5px;}


        #content, #map{
            position: relative;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;

        }


        .panel{
            position: absolute;
            z-index: 10;
            background: rgba(255,255,255,.8);
            padding: 10px;
        }
        .panel.position-tl{
            top: 10px;
            left: 100px;
        }
        .panel.position-tr{
            top: 40px;
            right: 5px;
        }
        .hide{
            display:none;
        }
        .heading{
            margin: 0;
            display: inline-block;
        }
        .vertical label{
            display: block;
            margin: 10px 0;
        }
        .horizontal label{
            margin-right: 20px;
            display: inline-block;
            vertical-align: baseline;
        }
        .horizontal select{
            position: relative;
            top: -1px;

        }

        .info-content{
            margin: 10px;
        }

            .info-content h3{
                margin: 0;
                border-bottom: 1px solid #eee;
                padding-bottom: 10px;
            }
            .info-content p{
                margin: 0;
                font-size: .9em;
                color: #999;
            }

            .info-content ul{
                list-style: none;
                padding: 0;
                margin: 0;
            }

            .info-content img{
                width: 100%;
                max-width: 100%;
                height: auto;
            }

        .info-content-icon{
            width: 50px;
            height: 50px;
            display: inline-block;
            border-radius: 4px;
            margin-right: 15px;
            border: 2px solid #eee;
            position: relative;
            vertical-align: text-top;
        }

        p.info-content-titles{
            margin-top: 1em;
            margin-bottom: 1px;
            color: #333;
        }

        .info-content-types{

        }

            .info-content-types li{
                font-size: .9em;
                color: #999;
            }


        .info-content-photos{

        }

            .info-content-photos li{
                display: inline-block;
                width: 50px;
                height: 50px;
                margin-right: 5px;
            }

            .info-content-photos img{

            }


    </style>

    <script type="text/javascript" src="http://maps.googleapis.com/maps/api/js?libraries=places&sensor=false"></script>
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.5.1/underscore-min.js"></script>
</head>
<body>
    <div id="content">
        <div id="map"></div>
    </div>

    <script>
        var map, hash, geocoder, boundaries, service, placeMarkers, infowindow;

        google.maps.visualRefresh = true;

        function getParks(callback){
            console.log("Get Parks")
            var counter = -1;
            d3.json("boundaries.json", function(error, rows) {

                console.log('Done loading')
                if(error){
                    return console.log(error);
                }

                boundaries = rows;

                //var polys = createPolygons(rows.features[0].geometry);
                //console.log(polys);

                callback();
            });
        }

        function setDisplayFromHash(){

        }

        function setHash(options){
            options = options || {};
            var hashStr = '';

            for(var item in options){
                hashStr += item + "=" + encodeURIComponent(options[item]) + "&";
            }

            if(!hashStr)return;

            // remove trailing &
            hashStr = hashStr.slice(0,-1);
            document.location.hash = hashStr;
        }

        function getHash(){
            var hashStr = document.location.hash;
            if(hashStr.charAt(0) == "#")hashStr = hashStr.slice(1);

            if(!hashStr.length){
                return null;
            }

            var hashParts = hashStr.split('&');

            var hashObj = {};
            hashParts.forEach(function(part){
                var params = part.split('=');
                hashObj[params[0]] = decodeURIComponent(params[1]);
            });

            return hashObj;
        }


        function initialize(){
            // loads park locations
            getParks(function(){

                // geocoder
                geocoder = new google.maps.Geocoder();

                // map options
                var mapOptions = {
                    center: new google.maps.LatLng(37.7706, -122.3782),
                    zoom: 11,
                    mapTypeId: google.maps.MapTypeId.TERRAIN,
                    mapTypeControlOptions: {
                        mapTypeIds: [google.maps.MapTypeId.TERRAIN, google.maps.MapTypeId.ROADMAP]
                    }
                };

                // map
                map = new google.maps.Map(document.getElementById('map'), mapOptions);

                //info-window
                infowindow = new google.maps.InfoWindow();

                // hash
                setDisplayFromHash();

                // container for markers
                placeMarkers = [];

                // boundaries
                boundaries.features.forEach(function(feature,i){
                    if( i < 100){
                        var polygon = createPolygons(feature.geometry);
                        var poly = polygon[0];
                        poly.__props = feature.properties;
                        poly.setMap(map);

                        google.maps.event.addListener(poly, 'click', boundaryClick);
                    }
                });

                service = new google.maps.places.PlacesService(map);

            });
        }

        function findNearByPlaces(bounds, latlng, callback){
            if(!service) return;

            var request = {
                types: [] // https://developers.google.com/places/documentation/supported_types
            };
            if(bounds){
                request.bounds = bounds;
            }else if(latlng){
                request.location = latlng;
                request.radius = 500;
            }



            service.nearbySearch(request, function(results, status){
                if (status == google.maps.places.PlacesServiceStatus.OK) {
                    return callback(results);
                }
                return callback(null);
            });
        }

        function makeInfoContent(place){
            var info = '<div class="info-content">';

            info += '<h3><span class="info-content-icon"><img src="' + place.icon + '"/></span>' + place.name + '</h3>';

            if(place.vicinity){
                info += '<p class="info-content-titles">Simplified Address</p>';
                info += '<p>' + place.vicinity + '</p>';
            }

            // types
            info += '<p class="info-content-titles">Types</p>';
            info += '<ul class="info-content-types">';
            place.types.forEach(function(t){
                info += '<li>' + t + '</li>';
            });
            info += '</ul>';

            // photos
            if(place.photos){
                info += '<p class="info-content-titles">Photos</p>';
                info += '<ul class="info-content-photos">';
                place.photos.forEach(function(photo){
                    info += '<li><img src="' + photo.getUrl({'maxWidth': 100, 'maxHeight': 100}) + '"/></li>';
                });
                info += '</ul>';
            }

            info += '</div>';

            return info;
        }

        function createMarker(place) {
            var placeLoc = place.geometry.location;
            var marker = new google.maps.Marker({
                map: map,
                position: place.geometry.location
            });


            google.maps.event.addListener(marker, 'click', function() {
                infowindow.setContent(makeInfoContent(place));
                infowindow.open(map, this);
            });

            placeMarkers.push(marker);
        }

        function getPolygonBounds(polygon){
            var coordinates = (polygon.getPath().getArray());
            var bounds = new google.maps.LatLngBounds();
            for (b in coordinates) {
                bounds.extend(coordinates[b]);
            };
            return bounds;
        }

        function boundaryClick(evt){
            console.log('click', this.__props );
            var lat = evt.latLng.lat(),
                lng = evt.latLng.lng(),
                bounds = getPolygonBounds(this),
                vertices = this.getPath(),
                properties = this.__props;

            console.log("Searching for places");

            // remove markers
            placeMarkers.forEach(function(marker){
                marker.setMap(null);
            });
            placeMarkers.length = 0;

            // filter
            var filter = '';
            findNearByPlaces(bounds, evt.latLng, function(results){
                if(results){
                    console.log(results);

                    for (var i = 0; i < results.length; i++) {
                        var place = results[i];
                        if(filter == 'photos'){
                            if(place.photos){
                                createMarker(results[i]);
                            }
                        }else{
                            createMarker(place);
                        }

                    }

                    // to test whether location is in polygon
                    //google.maps.geometry.poly.containsLocation(latlng, this)
                }
            });
        }

        function codeAddress(address, callback) {
            geocoder.geocode( { 'address': address}, function(results, status) {
                if (status == google.maps.GeocoderStatus.OK) {
                    callback(results[0].geometry.location)
                } else {
                    callback(null);
                }
            });
        }

        //TOOD: deal with multi-polygons
        function createPolygons(areajson, bounds){
            var coords = areajson.coordinates;
            var polygons = _(coords).reduce( function(memo_n, n) {
                var polygonpaths = _(n).reduce( function(memo_o, o) {
                    var mylatlng = new google.maps.LatLng(o[1], o[0]);

                    if(bounds){
                        bounds.extend(mylatlng);
                    }

                    memo_o.push(mylatlng);
                    return memo_o;
                }, []);
                var polygon = new google.maps.Polygon({
                  paths: polygonpaths,
                  strokeColor: "#333",
                  strokeOpacity: 0.8,
                  strokeWeight: 1,
                  fillColor: "#FF0099",
                  fillOpacity: 0.6
                });
                memo_n.push(polygon);
                return memo_n;
            }, []);

            return polygons;
        }

        google.maps.event.addDomListener(window, 'load', initialize);
    </script>
</body>
</html>