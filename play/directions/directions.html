<!DOCTYPE html>
<html>
  <meta charset="UTF-8">
  <head>
    <style>

      body,
      div#map,
      div#map svg {
        margin: 0;
        padding: 0;
      }

      body {
        background: #1a1a1a;
      }

      svg image {
        opacity: 0.2;
      }

      g.layer path {
        fill: none;
        stroke-linejoin: round;
        stroke-linecap: round;
        opacity: 0.5;
      }

      .zoom path {
        stroke: #fff;
      }
    </style>
  </head>

  <body>

    <div id="map"></div>

    <script src="https://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false"></script>
    <script src="js/vendor/d3.v3.js"></script>
    <script src="js/vendor/polymaps.js"></script>
    <script>
      var coords = {
        origin: {lat: 37.7706, lon: -122.3782},
        destination: {lat: 37.6527, lon: -120.9249}
      };

      var directionsService = new google.maps.DirectionsService();
      var features = [],
          endpoints = [],
          reqs = 10;

      d3.csv("locations.csv", function(locations) {
        // directionsService = new google.maps.DirectionsService();
        getendpoints(locations);
      });

      function getendpoints(locations) {
        endpoints = [];
        for (var i = 0; i < reqs; i++) {
          var idx = ~~(Math.random() * locations.length);
          endpoints.push(locations[idx]);
        }
        routes(endpoints);
      }


      var durations = [],
          size;
      function routes(endpoints) {
        var end = endpoints.length;
        endpoints.forEach(function(endpoint, i) {
          var request = {
            origin: new google.maps.LatLng(coords.origin.lat, coords.origin.lon),
            destination: new google.maps.LatLng(+endpoint.POINT_Y, +endpoint.POINT_X),
            travelMode: google.maps.TravelMode["DRIVING"]
          };
          directionsService.route(request, function(response, status) {
            if (status != google.maps.DirectionsStatus.OK) {
              console.log("failed to get directions!", status, response);
            } else {
              // console.log("response:", response.routes[0].legs[0]);
              var steps = response.routes[0].legs[0].steps;
              var feature = {
                type: "Feature",
                geometry: {
                  type: "MultiLineString",
                  coordinates: []
                },
                properties: {
                  duration: 0
                }
              };
              steps.forEach(function(step) {
                var line = step.path.map(function(point) {
                  return [point.kb, point.jb];
                });

                feature.properties.duration += parseFloat(step.duration.text);
                feature.geometry.coordinates.push(line);
              });
              features.push(feature);
            }
            if (--end === 0) {
              features.sort(function(a,b) { return d3.descending(a.properties.duration, b.properties.duration); });
              var extent = d3.extent(features, function(feat) { return feat.properties.duration; });
              size = d3.scale.linear().domain(extent).range([2, 50]);
              mapthat(features);
            }
          });
        });
      }

      var po = org.polymaps;
      
      var map = po.map()
          .container(document.getElementById("map").appendChild(po.svg("svg")))
          .center({lat: coords.origin.lat, lon: coords.origin.lon})
          .zoomRange([1, 20])
          .zoom(12)
          .add(po.interact())
          .add(po.hash());
      
      map.add(po.image()
          .url(po.url("http://tile.stamen.com/toner/{Z}/{X}/{Y}.jpg")
          .hosts(["a.", "b.", "c.", ""])));

      map.add(po.compass()
          .pan("none"));

      var geo = po.geoJson();
      function mapthat(features) {
        map.add(geo.features(features)
          .on("load", load));
      }

      function load(e) {
        e.features.forEach(function(feature, i) {
          // d3.select(feature.element).on("mouseover", function(d) { 
          //   console.log(feature.data.properties.durations[i]);
          // });
          var color = "hsl(" + Math.random() * 360 + ", 100%, 70%)";
          // console.log("duration:", feature.data.properties.duration, "; i:", i);
          // feature.element.parentNode.insertBefore(feature.element.parentNode.firstChild);
          feature.element.setAttribute("data-duration", feature.data.properties.duration);
          feature.element.setAttribute("stroke", color);
          feature.element.setAttribute("stroke-width", size(feature.data.properties.duration));
        });
      }


      // XXX to do it via request:
      // var url = ["http://maps.googleapis.com/maps/api/directions/json?origin=",
      //            coords.origin.lat + "," + coords.origin.lon,
      //            "&destination=",
      //            coords.destination.lat + "," + coords.destination.lon,
      //            "&sensor=false"].join("");

      // d3.json(url, function(error, json) {
      //   if (error) {
      //     console.log("error getting json!");
      //     return;
      //   }
      
      //   var steps = json.routes[0].legs[0].steps;
      //   var feature = {
      //     "type": "Feature",
      //       "geometry": {
      //         "type": "MultiLineString",
      //         "coordinates": []
      //       }
      //   };
      //   steps.forEach(function(step, idx) {
      //     // console.log(step.start_location, step.end_location);
      //     feature.geometry.coordinates.push([
      //       [step.start_location.lng, step.start_location.lat], 
      //       [step.end_location.lng, step.end_location.lat]
      //     ]);
      //     // if (idx === steps.length-1) {
      //     //   feature.coordinates.push([step.end_location.lat, step.end_location.lon]);
      //     // }
      //   });
        
      //   console.log(json, feature.geometry.coordinates);
      //   mapthat(feature);
      // });

    </script>

  </body>
</html>